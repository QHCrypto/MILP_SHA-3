// the array linearlayer_CP and linearlayer must match the width !!!
#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <cassert>
#include <chrono>
#include <csignal>
#include <gurobi_c++.h>
#define threads 8
using namespace std;
const vector<int> linearlayer_CP =
{ 0,   1,   2,   3,   4,   5,   6,   7,  52,  53,  54,  55,  48,  49,  50,  51, 101, 102, 103,  96,  97,  98,  99, 100, 147, 148, 149, 150, 151, 144, 145, 146, 194, 195, 196, 197, 198, 199, 192, 193,  28,  29,  30,  31,  24,  25,  26,  27,  76,  77,  78,  79,  72,  73,  74,  75,  85,  86,  87,  80,  81,  82,  83,  84, 131, 132, 133, 134, 135, 128, 129, 130, 179, 180, 181, 182, 183, 176, 177, 178,  15,   8,   9,  10,  11,  12,  13,  14,  58,  59,  60,  61,  62,  63,  56,  57, 111, 104, 105, 106, 107, 108, 109, 110, 152, 153, 154, 155, 156, 157, 158, 159, 166, 167, 160, 161, 162, 163, 164, 165,  37,  38,  39,  32,  33,  34,  35,  36,  44,  45,  46,  47,  40,  41,  42,  43,  94,  95,  88,  89,  90,  91,  92,  93, 137, 138, 139, 140, 141, 142, 143, 136, 184, 185, 186, 187, 188, 189, 190, 191,  18,  19,  20,  21,  22,  23,  16,  17,  65,  66,  67,  68,  69,  70,  71,  64, 113, 114, 115, 116, 117, 118, 119, 112, 127, 120, 121, 122, 123, 124, 125, 126, 174, 175, 168, 169, 170, 171, 172, 173 };
const vector<vector<int>> linearlayer = { {{0, 15, 32, 55, 72, 95, 112, 135, 152, 175, 192}, {1, 8, 33, 48, 73, 88, 113, 128, 153, 168, 193}, {2, 9, 34, 49, 74, 89, 114, 129, 154, 169, 194}, {3, 10, 35, 50, 75, 90, 115, 130, 155, 170, 195}, {4, 11, 36, 51, 76, 91, 116, 131, 156, 171, 196}, {5, 12, 37, 52, 77, 92, 117, 132, 157, 172, 197}, {6, 13, 38, 53, 78, 93, 118, 133, 158, 173, 198}, {7, 14, 39, 54, 79, 94, 119, 134, 159, 174, 199}, {4, 19, 44, 52, 59, 84, 99, 124, 139, 164, 179}, {5, 20, 45, 53, 60, 85, 100, 125, 140, 165, 180}, {6, 21, 46, 54, 61, 86, 101, 126, 141, 166, 181}, {7, 22, 47, 55, 62, 87, 102, 127, 142, 167, 182}, {0, 23, 40, 48, 63, 80, 103, 120, 143, 160, 183}, {1, 16, 41, 49, 56, 81, 96, 121, 136, 161, 176}, {2, 17, 42, 50, 57, 82, 97, 122, 137, 162, 177}, {3, 18, 43, 51, 58, 83, 98, 123, 138, 163, 178}, {13, 28, 53, 68, 93, 101, 108, 133, 148, 173, 188}, {14, 29, 54, 69, 94, 102, 109, 134, 149, 174, 189}, {15, 30, 55, 70, 95, 103, 110, 135, 150, 175, 190}, {8, 31, 48, 71, 88, 96, 111, 128, 151, 168, 191}, {9, 24, 49, 64, 89, 97, 104, 129, 144, 169, 184}, {10, 25, 50, 65, 90, 98, 105, 130, 145, 170, 185}, {11, 26, 51, 66, 91, 99, 106, 131, 146, 171, 186}, {12, 27, 52, 67, 92, 100, 107, 132, 147, 172, 187}, {19, 34, 59, 74, 99, 114, 139, 147, 154, 179, 194}, {20, 35, 60, 75, 100, 115, 140, 148, 155, 180, 195}, {21, 36, 61, 76, 101, 116, 141, 149, 156, 181, 196}, {22, 37, 62, 77, 102, 117, 142, 150, 157, 182, 197}, {23, 38, 63, 78, 103, 118, 143, 151, 158, 183, 198}, {16, 39, 56, 79, 96, 119, 136, 144, 159, 176, 199}, {17, 32, 57, 72, 97, 112, 137, 145, 152, 177, 192}, {18, 33, 58, 73, 98, 113, 138, 146, 153, 178, 193}, {1, 26, 41, 66, 81, 106, 121, 146, 161, 186, 194}, {2, 27, 42, 67, 82, 107, 122, 147, 162, 187, 195}, {3, 28, 43, 68, 83, 108, 123, 148, 163, 188, 196}, {4, 29, 44, 69, 84, 109, 124, 149, 164, 189, 197}, {5, 30, 45, 70, 85, 110, 125, 150, 165, 190, 198}, {6, 31, 46, 71, 86, 111, 126, 151, 166, 191, 199}, {7, 24, 47, 64, 87, 104, 127, 144, 167, 184, 192}, {0, 25, 40, 65, 80, 105, 120, 145, 160, 185, 193}, {20, 28, 35, 60, 75, 100, 115, 140, 155, 180, 195}, {21, 29, 36, 61, 76, 101, 116, 141, 156, 181, 196}, {22, 30, 37, 62, 77, 102, 117, 142, 157, 182, 197}, {23, 31, 38, 63, 78, 103, 118, 143, 158, 183, 198}, {16, 24, 39, 56, 79, 96, 119, 136, 159, 176, 199}, {17, 25, 32, 57, 72, 97, 112, 137, 152, 177, 192}, {18, 26, 33, 58, 73, 98, 113, 138, 153, 178, 193}, {19, 27, 34, 59, 74, 99, 114, 139, 154, 179, 194}, {3, 28, 43, 68, 76, 83, 108, 123, 148, 163, 188}, {4, 29, 44, 69, 77, 84, 109, 124, 149, 164, 189}, {5, 30, 45, 70, 78, 85, 110, 125, 150, 165, 190}, {6, 31, 46, 71, 79, 86, 111, 126, 151, 166, 191}, {7, 24, 47, 64, 72, 87, 104, 127, 144, 167, 184}, {0, 25, 40, 65, 73, 80, 105, 120, 145, 160, 185}, {1, 26, 41, 66, 74, 81, 106, 121, 146, 161, 186}, {2, 27, 42, 67, 75, 82, 107, 122, 147, 162, 187}, {12, 37, 52, 77, 85, 92, 117, 132, 157, 172, 197}, {13, 38, 53, 78, 86, 93, 118, 133, 158, 173, 198}, {14, 39, 54, 79, 87, 94, 119, 134, 159, 174, 199}, {15, 32, 55, 72, 80, 95, 112, 135, 152, 175, 192}, {8, 33, 48, 73, 81, 88, 113, 128, 153, 168, 193}, {9, 34, 49, 74, 82, 89, 114, 129, 154, 169, 194}, {10, 35, 50, 75, 83, 90, 115, 130, 155, 170, 195}, {11, 36, 51, 76, 84, 91, 116, 131, 156, 171, 196}, {3, 18, 43, 58, 83, 98, 123, 131, 138, 163, 178}, {4, 19, 44, 59, 84, 99, 124, 132, 139, 164, 179}, {5, 20, 45, 60, 85, 100, 125, 133, 140, 165, 180}, {6, 21, 46, 61, 86, 101, 126, 134, 141, 166, 181}, {7, 22, 47, 62, 87, 102, 127, 135, 142, 167, 182}, {0, 23, 40, 63, 80, 103, 120, 128, 143, 160, 183}, {1, 16, 41, 56, 81, 96, 121, 129, 136, 161, 176}, {2, 17, 42, 57, 82, 97, 122, 130, 137, 162, 177}, {11, 26, 51, 66, 91, 106, 131, 146, 171, 179, 186}, {12, 27, 52, 67, 92, 107, 132, 147, 172, 180, 187}, {13, 28, 53, 68, 93, 108, 133, 148, 173, 181, 188}, {14, 29, 54, 69, 94, 109, 134, 149, 174, 182, 189}, {15, 30, 55, 70, 95, 110, 135, 150, 175, 183, 190}, {8, 31, 48, 71, 88, 111, 128, 151, 168, 176, 191}, {9, 24, 49, 64, 89, 104, 129, 144, 169, 177, 184}, {10, 25, 50, 65, 90, 105, 130, 145, 170, 178, 185}, {7, 15, 22, 47, 62, 87, 102, 127, 142, 167, 182}, {0, 8, 23, 40, 63, 80, 103, 120, 143, 160, 183}, {1, 9, 16, 41, 56, 81, 96, 121, 136, 161, 176}, {2, 10, 17, 42, 57, 82, 97, 122, 137, 162, 177}, {3, 11, 18, 43, 58, 83, 98, 123, 138, 163, 178}, {4, 12, 19, 44, 59, 84, 99, 124, 139, 164, 179}, {5, 13, 20, 45, 60, 85, 100, 125, 140, 165, 180}, {6, 14, 21, 46, 61, 86, 101, 126, 141, 166, 181}, {10, 25, 50, 58, 65, 90, 105, 130, 145, 170, 185}, {11, 26, 51, 59, 66, 91, 106, 131, 146, 171, 186}, {12, 27, 52, 60, 67, 92, 107, 132, 147, 172, 187}, {13, 28, 53, 61, 68, 93, 108, 133, 148, 173, 188}, {14, 29, 54, 62, 69, 94, 109, 134, 149, 174, 189}, {15, 30, 55, 63, 70, 95, 110, 135, 150, 175, 190}, {8, 31, 48, 56, 71, 88, 111, 128, 151, 168, 191}, {9, 24, 49, 57, 64, 89, 104, 129, 144, 169, 184}, {23, 38, 63, 78, 103, 111, 118, 143, 158, 183, 198}, {16, 39, 56, 79, 96, 104, 119, 136, 159, 176, 199}, {17, 32, 57, 72, 97, 105, 112, 137, 152, 177, 192}, {18, 33, 58, 73, 98, 106, 113, 138, 153, 178, 193}, {19, 34, 59, 74, 99, 107, 114, 139, 154, 179, 194}, {20, 35, 60, 75, 100, 108, 115, 140, 155, 180, 195}, {21, 36, 61, 76, 101, 109, 116, 141, 156, 181, 196}, {22, 37, 62, 77, 102, 110, 117, 142, 157, 182, 197}, {7, 24, 47, 64, 87, 104, 127, 144, 152, 167, 184}, {0, 25, 40, 65, 80, 105, 120, 145, 153, 160, 185}, {1, 26, 41, 66, 81, 106, 121, 146, 154, 161, 186}, {2, 27, 42, 67, 82, 107, 122, 147, 155, 162, 187}, {3, 28, 43, 68, 83, 108, 123, 148, 156, 163, 188}, {4, 29, 44, 69, 84, 109, 124, 149, 157, 164, 189}, {5, 30, 45, 70, 85, 110, 125, 150, 158, 165, 190}, {6, 31, 46, 71, 86, 111, 126, 151, 159, 166, 191}, {13, 38, 53, 78, 93, 118, 133, 158, 166, 173, 198}, {14, 39, 54, 79, 94, 119, 134, 159, 167, 174, 199}, {15, 32, 55, 72, 95, 112, 135, 152, 160, 175, 192}, {8, 33, 48, 73, 88, 113, 128, 153, 161, 168, 193}, {9, 34, 49, 74, 89, 114, 129, 154, 162, 169, 194}, {10, 35, 50, 75, 90, 115, 130, 155, 163, 170, 195}, {11, 36, 51, 76, 91, 116, 131, 156, 164, 171, 196}, {12, 37, 52, 77, 92, 117, 132, 157, 165, 172, 197}, {4, 29, 37, 44, 69, 84, 109, 124, 149, 164, 189}, {5, 30, 38, 45, 70, 85, 110, 125, 150, 165, 190}, {6, 31, 39, 46, 71, 86, 111, 126, 151, 166, 191}, {7, 24, 32, 47, 64, 87, 104, 127, 144, 167, 184}, {0, 25, 33, 40, 65, 80, 105, 120, 145, 160, 185}, {1, 26, 34, 41, 66, 81, 106, 121, 146, 161, 186}, {2, 27, 35, 42, 67, 82, 107, 122, 147, 162, 187}, {3, 28, 36, 43, 68, 83, 108, 123, 148, 163, 188}, {11, 36, 44, 51, 76, 91, 116, 131, 156, 171, 196}, {12, 37, 45, 52, 77, 92, 117, 132, 157, 172, 197}, {13, 38, 46, 53, 78, 93, 118, 133, 158, 173, 198}, {14, 39, 47, 54, 79, 94, 119, 134, 159, 174, 199}, {15, 32, 40, 55, 72, 95, 112, 135, 152, 175, 192}, {8, 33, 41, 48, 73, 88, 113, 128, 153, 168, 193}, {9, 34, 42, 49, 74, 89, 114, 129, 154, 169, 194}, {10, 35, 43, 50, 75, 90, 115, 130, 155, 170, 195}, {6, 21, 46, 61, 86, 94, 101, 126, 141, 166, 181}, {7, 22, 47, 62, 87, 95, 102, 127, 142, 167, 182}, {0, 23, 40, 63, 80, 88, 103, 120, 143, 160, 183}, {1, 16, 41, 56, 81, 89, 96, 121, 136, 161, 176}, {2, 17, 42, 57, 82, 90, 97, 122, 137, 162, 177}, {3, 18, 43, 58, 83, 91, 98, 123, 138, 163, 178}, {4, 19, 44, 59, 84, 92, 99, 124, 139, 164, 179}, {5, 20, 45, 60, 85, 93, 100, 125, 140, 165, 180}, {9, 24, 49, 64, 89, 104, 129, 137, 144, 169, 184}, {10, 25, 50, 65, 90, 105, 130, 138, 145, 170, 185}, {11, 26, 51, 66, 91, 106, 131, 139, 146, 171, 186}, {12, 27, 52, 67, 92, 107, 132, 140, 147, 172, 187}, {13, 28, 53, 68, 93, 108, 133, 141, 148, 173, 188}, {14, 29, 54, 69, 94, 109, 134, 142, 149, 174, 189}, {15, 30, 55, 70, 95, 110, 135, 143, 150, 175, 190}, {8, 31, 48, 71, 88, 111, 128, 136, 151, 168, 191}, {16, 39, 56, 79, 96, 119, 136, 159, 176, 184, 199}, {17, 32, 57, 72, 97, 112, 137, 152, 177, 185, 192}, {18, 33, 58, 73, 98, 113, 138, 153, 178, 186, 193}, {19, 34, 59, 74, 99, 114, 139, 154, 179, 187, 194}, {20, 35, 60, 75, 100, 115, 140, 155, 180, 188, 195}, {21, 36, 61, 76, 101, 116, 141, 156, 181, 189, 196}, {22, 37, 62, 77, 102, 117, 142, 157, 182, 190, 197}, {23, 38, 63, 78, 103, 118, 143, 158, 183, 191, 198}, {10, 18, 25, 50, 65, 90, 105, 130, 145, 170, 185}, {11, 19, 26, 51, 66, 91, 106, 131, 146, 171, 186}, {12, 20, 27, 52, 67, 92, 107, 132, 147, 172, 187}, {13, 21, 28, 53, 68, 93, 108, 133, 148, 173, 188}, {14, 22, 29, 54, 69, 94, 109, 134, 149, 174, 189}, {15, 23, 30, 55, 70, 95, 110, 135, 150, 175, 190}, {8, 16, 31, 48, 71, 88, 111, 128, 151, 168, 191}, {9, 17, 24, 49, 64, 89, 104, 129, 144, 169, 184}, {17, 32, 57, 65, 72, 97, 112, 137, 152, 177, 192}, {18, 33, 58, 66, 73, 98, 113, 138, 153, 178, 193}, {19, 34, 59, 67, 74, 99, 114, 139, 154, 179, 194}, {20, 35, 60, 68, 75, 100, 115, 140, 155, 180, 195}, {21, 36, 61, 69, 76, 101, 116, 141, 156, 181, 196}, {22, 37, 62, 70, 77, 102, 117, 142, 157, 182, 197}, {23, 38, 63, 71, 78, 103, 118, 143, 158, 183, 198}, {16, 39, 56, 64, 79, 96, 119, 136, 159, 176, 199}, {0, 25, 40, 65, 80, 105, 113, 120, 145, 160, 185}, {1, 26, 41, 66, 81, 106, 114, 121, 146, 161, 186}, {2, 27, 42, 67, 82, 107, 115, 122, 147, 162, 187}, {3, 28, 43, 68, 83, 108, 116, 123, 148, 163, 188}, {4, 29, 44, 69, 84, 109, 117, 124, 149, 164, 189}, {5, 30, 45, 70, 85, 110, 118, 125, 150, 165, 190}, {6, 31, 46, 71, 86, 111, 119, 126, 151, 166, 191}, {7, 24, 47, 64, 87, 104, 112, 127, 144, 167, 184}, {14, 39, 54, 79, 94, 119, 127, 134, 159, 174, 199}, {15, 32, 55, 72, 95, 112, 120, 135, 152, 175, 192}, {8, 33, 48, 73, 88, 113, 121, 128, 153, 168, 193}, {9, 34, 49, 74, 89, 114, 122, 129, 154, 169, 194}, {10, 35, 50, 75, 90, 115, 123, 130, 155, 170, 195}, {11, 36, 51, 76, 91, 116, 124, 131, 156, 171, 196}, {12, 37, 52, 77, 92, 117, 125, 132, 157, 172, 197}, {13, 38, 53, 78, 93, 118, 126, 133, 158, 173, 198}, {6, 21, 46, 61, 86, 101, 126, 141, 166, 174, 181}, {7, 22, 47, 62, 87, 102, 127, 142, 167, 175, 182}, {0, 23, 40, 63, 80, 103, 120, 143, 160, 168, 183}, {1, 16, 41, 56, 81, 96, 121, 136, 161, 169, 176}, {2, 17, 42, 57, 82, 97, 122, 137, 162, 170, 177}, {3, 18, 43, 58, 83, 98, 123, 138, 163, 171, 178}, {4, 19, 44, 59, 84, 99, 124, 139, 164, 172, 179}, {5, 20, 45, 60, 85, 100, 125, 140, 165, 173, 180}} };

#define index(x, y, z) ((((x) % 5) + 5 * ((y) % 5)) * (width / 25) + ((z) % (width / 25)))
GRBEnv env = GRBEnv();
GRBModel model = GRBModel(env);
//#define width 800
#define width 200
GRBVar x0[width], Y0[width], z0[width], x1[width], y1[width], z1[width], x2[width], y2[width], z2[width], x3[width], y3[width], t0[width / 5][3], t1[width / 5][3], t2[width / 5][3], t3[width / 5][3];
const int ineqs_prob[6][8] = {{-3, -4, 1, 2, 2, 1, 3, 2}, {2, 4, -2, -2, -1, 1, -1, 0}, {-3, -4, 1, 4, -1, 2, 2, 4}, {2, 4, 0, -1, -2, -2, -1, 0}, {1, 3, -2, 0, 0, -1, -2, 1}, {-3, -4, 4, 1, 2, 2, 1, 2}};
const int ineqs_diff[26][11] = {{6, 6, 2, 7, 7, 0, -3, 5, -3, -1, 0}, {-3, -10, -10, 1, -3, 7, -10, -10, 2, -8, 44}, {7, -1, 1, -1, 7, -7, -1, -1, 6, -1, 5}, {4, 3, -10, -10, 2, -10, 7, -10, -6, 2, 36}, {1, -1, 7, 7, -1, -1, 6, -1, -7, -1, 5}, {0, -1, 9, -16, -4, 1, 15, 9, 18, 3, 2}, {3, -12, -12, 2, 4, 9, -12, -8, 2, -12, 44}, {27, -20, -3, 3, -1, -10, 20, -2, 10, 28, 6}, {1, -4, 2, -11, 22, 3, -7, 22, -11, 9, 22}, {-12, 2, 4, 3, -12, -8, 2, -12, 9, -12, 44}, {12, 0, -2, 1, -6, 5, 2, -4, 12, -6, 12}, {-10, -10, 1, -3, -3, -10, -10, 2, -8, 7, 44}, {-4, -9, 20, -1, 2, 32, 29, -19, 5, 11, 0}, {2, 31, -24, 1, -4, 29, -13, 22, 3, 11, 6}, {-11, -11, 3, 4, 2, -11, -7, 1, -11, 9, 40}, {1, -3, -3, -10, -10, 2, -8, 7, -10, -10, 44}, {-1, 1, -1, 7, 7, -1, -1, 6, -1, -7, 5}, {0, 0, -4, 3, -1, 4, 7, 7, -2, 1, 0}, {-1, -4, 4, 18, -19, 4, -4, 19, 2, 16, 8}, {2, 4, 3, -12, -12, 2, -12, 9, -12, -8, 44}, {-1, -1, -2, -2, 1, -2, 1, -2, -2, 0, 10}, {-1, 7, 7, -1, 1, 6, -1, -7, -1, -1, 5}, {-10, 1, -3, -3, -10, -10, 2, -8, 7, -10, 44}, {-24, 1, -4, 2, 31, 22, 3, 11, 29, -13, 6}, {-7, 16, -2, 2, -1, -7, 16, -1, -5, 16, 16}, {7, 7, -1, 1, -1, -1, -7, -1, -1, 6, 5}};
ofstream ofs;
void Handle_SIGINT(int sig)
{
    model.terminate();
}
void log(GRBVar output[width])
{
    for (int i = 0; i < 5; ++i)
    {
        for (int j = 0; j < 5; ++j)
        {
            ofs << "|";
            for (int k = width / 25 - 1; k >= 0; k -= 4)
            {
                int temp = 0;
                for (int kk = 0; kk < 4; ++kk)
                {
                    int ttemp = output[index(j, i, k - kk)].get(GRB_DoubleAttr_X);
                    temp += ttemp << (3 - kk);
                }
                if (temp == 0)
                    ofs << "-";
                else
                    ofs << hex << temp;
            }
        }
        ofs << "|" << endl;
    }
}
void log2(int output[width])
{
    for (int i = 0; i < 5; ++i)
    {
        for (int j = 0; j < 5; ++j)
        {
            cout << "|";
            for (int k = width / 25 - 1; k >= 0; k -= 4)
            {
                int temp = 0;
                for (int kk = 0; kk < 4; ++kk)
                {
                    int ttemp = output[index(j, i, k - kk)];
                    temp += ttemp << (3 - kk);
                }
                if (temp == 0)
                    cout << "-";
                else
                    cout << hex << temp;
            }
        }
        cout << "|" << endl;
    }
}

int main()
{
    signal(SIGINT, Handle_SIGINT);
    ios::sync_with_stdio(false);
    auto start = chrono::system_clock::now();
    try
    {
        model.set(GRB_IntParam_Threads, 8);
        model.set(GRB_DoubleParam_TimeLimit, 1000);
        // model.set(GRB_DoubleParam_NoRelHeurTime, 600);
        // model.set(GRB_IntParam_OutputFlag, 0);
        // model.set(GRB_IntParam_MIPFocus, GRB_MIPFOCUS_BALANCED);//0
        model.set(GRB_IntParam_MIPFocus, GRB_MIPFOCUS_FEASIBILITY);//1
        // model.set(GRB_IntParam_MIPFocus, GRB_MIPFOCUS_OPTIMALITY);//2
        // model.set(GRB_IntParam_MIPFocus, GRB_MIPFOCUS_BESTBOUND);//3
        // t_r[i] models the i-th sbox of round r
        // if i-th sbox of round r is active, t_r[i][0] = 0
        // otherwise, t_r[i][0] = 1
        // t_r[i][1] and t_r[i][2] models the probability according to the DDT
        for (int i = 0; i < width / 5; ++i)
            for (int j = 0; j < 3; ++j)
            {
                t0[i][j] = model.addVar(0, 1, 0, GRB_BINARY);
                t1[i][j] = model.addVar(0, 1, 0, GRB_BINARY);
                t2[i][j] = model.addVar(0, 1, 0, GRB_BINARY);
                t3[i][j] = model.addVar(0, 1, 0, GRB_BINARY);
            }

        // x_r models the state at the beginning of the round r
        // y_r models the state after linear layer(\theta,\rho,\pi) of the round r
        // z_r models the state after unlinear layer (\chi) of the round r
        for (int i = 0; i < width; ++i)
        {
            y1[i] = model.addVar(0, 1, 0, GRB_BINARY);
            z1[i] = model.addVar(0, 1, 0, GRB_BINARY);
            x2[i] = model.addVar(0, 1, 0, GRB_BINARY);
            y2[i] = model.addVar(0, 1, 0, GRB_BINARY);
            z2[i] = model.addVar(0, 1, 0, GRB_BINARY);
            x3[i] = model.addVar(0, 1, 0, GRB_BINARY);
            y3[i] = model.addVar(0, 1, 0, GRB_BINARY);
        }

		// optional
        // initialize a feasible solution
		int initialize_solution[width];
		for (int i = 0; i < width; ++i)
			initialize_solution[i] = 0;
		initialize_solution[index(0, 0, 1)] = 1;
		initialize_solution[index(0, 0, 3)] = 1;
		initialize_solution[index(1, 0, 5)] = 1;
        initialize_solution[index(2, 0, 3)] = 1;
        initialize_solution[index(2, 0, 5)] = 1;
        initialize_solution[index(3, 0, 5)] = 1;
        initialize_solution[index(4, 0, 3)] = 1;

		initialize_solution[index(0, 2, 3)] = 1;
		initialize_solution[index(3, 2, 5)] = 1;
        initialize_solution[index(4, 2, 3)] = 1;
		for (int i = 0; i < width; ++i)
			y1[i].set(GRB_DoubleAttr_Start, initialize_solution[i]);
        printf("y1=\n");
        log2(initialize_solution);

        for (int i = 0; i < width; ++i)
            initialize_solution[i] = 0;
        initialize_solution[index(0, 0, 3)] = 1;
        initialize_solution[index(3, 0, 5)] = 1;

        initialize_solution[index(0, 2, 3)] = 1;
        initialize_solution[index(3, 2, 5)] = 1;
        for (int i = 0; i < width; ++i)
            x2[i].set(GRB_DoubleAttr_Start, initialize_solution[i]);
        printf("x2=\n");
        log2(initialize_solution);

        for (int i = 0; i < width; ++i)
            initialize_solution[i] = 0;
        initialize_solution[index(0, 0, 1)] = 1;

        initialize_solution[index(0, 1, 1)] = 1;
        initialize_solution[index(2, 1, 6)] = 1;

        initialize_solution[index(2, 2, 6)] = 1;
        for (int i = 0; i < width; ++i)
            x3[i].set(GRB_DoubleAttr_Start, initialize_solution[i]);
        printf("x3=\n");
        log2(initialize_solution);
        // linear layer
        for (int i = 0; i < width; ++i)
        {
            // CP-kernel
            model.addConstr(y2[i], GRB_EQUAL, x2[linearlayer_CP[i]]);
            //model.addConstr(y3[i], GRB_EQUAL, x3[linearlayer_CP[i]]);

            // without CP-kernel
            GRBVar temp = model.addVar(0, 5, 0, GRB_INTEGER);
            GRBLinExpr constr = -2 * temp;
            for (auto p : linearlayer[i])
                constr += x3[p];
            model.addConstr(constr, GRB_EQUAL, y3[i]);
        }

        // CP-kernel constraints
        for (int i = 0; i < 5; ++i)
            for (int j = 0; j < width / 25; ++j)
            {
                GRBVar temp = model.addVar(0, 5, 0, GRB_INTEGER);
                GRBLinExpr constr = -2 * temp;
                for (int k = 0; k < 5; ++k)
                    constr += x2[index(i, k, j)];
                model.addConstr(constr, GRB_EQUAL, 0);
            }

        // iota
        // 0x02 for lanesize = 8
        for (int i = 0; i < width; ++i)
        {
            if (i == 1)
                model.addConstr(x2[i] + z1[i], GRB_EQUAL, 1);
            else
                model.addConstr(x2[i], GRB_EQUAL, z1[i]);
        }
        // 0x0A for lanesize = 8
        for (int i = 0; i < width; ++i)
        {
			if (i == 1 || i == 3)
                model.addConstr(x3[i] + z2[i], GRB_EQUAL, 1);
            else
                model.addConstr(x3[i], GRB_EQUAL, z2[i]);
        }

        // unlinear layer (\chi)
        for (int i = 0; i < 5; ++i)
            for (int j = 0; j < width / 25; ++j)
            {
                // constraints between active sbox and input differences
				GRBLinExpr t1sum = 0, t2sum = 0, t3sum = 0;
                for (int k = 0; k < 5; ++k)
                {
                    t1sum += y1[index(k, i, j)];
                    t2sum += y2[index(k, i, j)];
                    t3sum += y3[index(k, i, j)];
                }
                model.addConstr(5 * t1[i * width / 25 + j][2], GRB_GREATER_EQUAL, t1sum);
                model.addConstr(5 * t2[i * width / 25 + j][2], GRB_GREATER_EQUAL, t2sum);
				model.addConstr(5 * t3[i * width / 25 + j][2], GRB_GREATER_EQUAL, t3sum);
                model.addConstr(t1[i * width / 25 + j][2], GRB_LESS_EQUAL, t1sum);
                model.addConstr(t2[i * width / 25 + j][2], GRB_LESS_EQUAL, t2sum);
                model.addConstr(t3[i * width / 25 + j][2], GRB_LESS_EQUAL, t3sum);

                // constraints between input differences and output differences without probabilities
                for (int k = 0; k < 26; ++k)
                {
                    GRBLinExpr constr_diff = ineqs_diff[k][10];
                    for (int p = 0; p < 5; ++p)
                        constr_diff += ineqs_diff[k][p] * z1[index(4 - p, i, j)] + ineqs_diff[k][p + 5] * y1[index(4 - p, i, j)];
                    model.addConstr(constr_diff, GRB_GREATER_EQUAL, 0);

                    constr_diff = ineqs_diff[k][10];
                    for (int p = 0; p < 5; ++p)
                        constr_diff += ineqs_diff[k][p] * z2[index(4 - p, i, j)] + ineqs_diff[k][p + 5] * y2[index(4 - p, i, j)];
                    model.addConstr(constr_diff, GRB_GREATER_EQUAL, 0);
                }

                // constraints between input differences and probabilities (probabilities only depend on the input differences)
                for (int k = 0; k < 6; ++k)
                {
                    GRBLinExpr constr_prob = t1[width / 25 * i + j][0] * ineqs_prob[k][0] + t1[width / 25 * i + j][1] * ineqs_prob[k][1] + ineqs_prob[k][7];
					for (int p = 0; p < 5; ++p)
						constr_prob += ineqs_prob[k][p + 2] * y1[index(4 - p, i, j)];
					model.addConstr(constr_prob, GRB_GREATER_EQUAL, 0);

                    constr_prob = t2[width / 25 * i + j][0] * ineqs_prob[k][0] + t2[width / 25 * i + j][1] * ineqs_prob[k][1] + ineqs_prob[k][7];
                    for (int p = 0; p < 5; ++p)
                        constr_prob += ineqs_prob[k][p + 2] * y2[index(4 - p, i, j)];
                    model.addConstr(constr_prob, GRB_GREATER_EQUAL, 0);

                    constr_prob = t3[width / 25 * i + j][0] * ineqs_prob[k][0] + t3[width / 25 * i + j][1] * ineqs_prob[k][1] + ineqs_prob[k][7];
                    for (int p = 0; p < 5; ++p)
                        constr_prob += ineqs_prob[k][p + 2] * y3[index(4 - p, i, j)];
                    model.addConstr(constr_prob, GRB_GREATER_EQUAL, 0);
                }
            }

		GRBLinExpr k2, k3, k4;
        for (int i = 0; i < width / 5; ++i)
        {
            k2 += t1[i][0] + t1[i][1] * 2 + t1[i][2];
            k3 += t2[i][0] + t2[i][1] * 2 + t2[i][2];
            k4 += t3[i][0] + t3[i][1] * 2 + t3[i][2];
        }
        auto k2value = model.addVar(0, width, 0, GRB_INTEGER);
        model.addConstr(k2, GRB_EQUAL, k2value);
        auto k3value = model.addVar(0, width, 0, GRB_INTEGER);
        model.addConstr(k3, GRB_EQUAL, k3value);
        auto k4value = model.addVar(0, width, 0, GRB_INTEGER);
        model.addConstr(k4, GRB_EQUAL, k4value);
		model.setObjective(2 * k3 + k4, GRB_MINIMIZE);
		model.update();
		model.optimize();
		ofs.open("5rkeccak400.txt");
		ofs << "y1:" << endl;
		log(y1);
        ofs << "z1:" << endl;
        log(z1);
        ofs << "x2:" << endl;
        log(x2);
        ofs << "y2:" << endl;
        log(y2);
        ofs << "z2:" << endl;
        log(z2);
        ofs << "x3:" << endl;
        log(x3);
        ofs << "y3:" << endl;
        log(y3);
        ofs.close();
        std::cout << "k2:" << k2value.get(GRB_DoubleAttr_X) << endl;
        std::cout << "k3:" << k3value.get(GRB_DoubleAttr_X) << endl;
        std::cout << "k4:" << k4value.get(GRB_DoubleAttr_X) << endl;
    }
    catch (GRBException e)
    {
        std::cout << "Error code = " << e.getErrorCode() << endl;
        std::cout << e.getMessage() << endl;
    }
    auto end = chrono::system_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(end - start);
    std::cout << double(duration.count()) * chrono::microseconds::period::num /
                     chrono::microseconds::period::den
              << "s" << endl;
    return 0;
}